#!/usr/bin/env python
# coding: utf-8

# In[ ]:


# Задание 1. Реализовать класс «Дата», функция-конструктор которого должна принимать дату в виде строки формата «день-месяц-год».
#В рамках класса реализовать два метода. Первый, с декоратором @classmethod. Он должен извлекать число, месяц, год и 
#преобразовывать их тип к типу «Число». Второй, с декоратором @staticmethod, должен проводить валидацию числа, месяца и года 
#(например, месяц — от 1 до 12). Проверить работу полученной структуры на реальных данных.

from datetime import date


class Data:
    def __init__(self, data):
        self.data = data.split('-')

    @classmethod
    def type(cls, data):
        try:
            day, month, year = [int(i) for i in data.split('-')]
            return f"{type(day), day}\n{type(month), month}\n{type(year), year}"
        except ValueError:
            return 'Указана неправильная дата!'

    @staticmethod
    def valid(data):
        try:
            day, month, year = data.split('-')
            date(int(year), int(month), int(day))
            return 'Есть такая дата!'
        except ValueError:
            return 'Указана неправильная дата!'


print(Data.valid('10-03-2023'))
print(Data.type('10-03'))


# In[ ]:


#Задание 2. Создайте собственный класс-исключение, обрабатывающий ситуацию деления на ноль. Проверьте его работу на данных, 
#вводимых пользователем. При вводе нуля в качестве делителя программа должна корректно обработать эту ситуацию и не завершиться 
#с ошибкой.

class OwnError(Exception):
    def __init__(self, txt):
        self.txt = txt


def div():
    try:
        user_num_1 = int(input('Введите делимое: '))
        user_num_2 = int(input('Введите делитель: '))
        if user_num_2 == 0:
            raise OwnError("Делить на ноль нельзя!")
        else:
            res = user_num_1 / user_num_2
            return res
    except ValueError:
        return "Вы ввели не число"
    except OwnError as err:
        return err


print(div())


# In[ ]:


#Задание 3.
#Создайте собственный класс-исключение, который должен проверять содержимое списка на наличие только чисел. Проверить работу 
#исключения на реальном примере. Запрашивать у пользователя данные и заполнять список необходимо только числами. Класс-исключение
#должен контролировать типы данных элементов списка.
#Примечание: длина списка не фиксирована. Элементы запрашиваются бесконечно, пока пользователь сам не остановит работу скрипта, 
#введя, например, команду «stop». При этом скрипт завершается, сформированный список с числами выводится на экран.
#Подсказка: для этого задания примем, что пользователь может вводить только числа и строки. Во время ввода пользователем 
#очередного элемента необходимо реализовать проверку типа элемента. Вносить его в список, только если введено число. 
#Класс-исключение должен не позволить пользователю ввести текст (не число) и отобразить соответствующее сообщение. При этом 
#работа скрипта не должна завершаться.

class OwnError(Exception):
    def __init__(self, txt):
        self.txt = txt


def div():
    try:
        user_num_1 = int(input('Введите делимое: '))
        user_num_2 = int(input('Введите делитель: '))
        if user_num_2 == 0:
            raise OwnError("Делить на ноль нельзя!")
        else:
            res = user_num_1 / user_num_2
            return res
    except ValueError:
        return "Вы ввели не число"
    except OwnError as err:
        return err


print(div())


# In[ ]:


#Задание 4,5.6 Начните работу над проектом «Склад оргтехники». Создайте класс, описывающий склад. А также класс «Оргтехника», 
#который будетразовым для классов-наследников. Эти классы — конкретные типы оргтехники (принтер, сканер, ксерокс). В базовом 
#классе определите параметры, общие для приведённых типов. В классах-наследниках реализуйте параметры, уникальные для каждого 
#типа оргтехники.Продолжить работу над первым заданием. Разработайте методы, которые отвечают за приём оргтехники на склад и 
#передачу вопределённое подразделение компании. Для хранения данных о наименовании и количестве единиц оргтехники, а также других данных, 
#можно использовать любую подходящую структуру (например, словарь).
#Продолжить работу над вторым заданием. Реализуйте механизм валидации вводимых пользователем данных. Например, для указания 
#количества принтеров, отправленных на склад, нельзя использовать строковый тип данных.
#Подсказка: постарайтесь реализовать в проекте «Склад оргтехники» максимум возможностей, изученных на уроках по ООП.

class OfficeEquipment:

    def __init__(self, name, price, quantity):
        self.name = name
        self.price = price
        self.quantity = quantity
        self.items = {'Модель устройства': self.name, 'Цена за ед': self.price, 'Количество': self.quantity}

    def income(self):
        try:
            name = input(f'Введите наименование: ')
            price = int(input(f'Введите цену за ед: '))
            quantity = int(input(f'Введите количество: '))
            item = {'Модель устройства': name, 'Цена за ед': price, 'Количество': quantity}
            self.items.update(item)
            print(self.items)
        except ValueError:
            print('Недопустимое значение!')


class Printer(OfficeEquipment):
    pass


class Scanner(OfficeEquipment):
    pass


class Xerox(OfficeEquipment):
    pass


p = Printer('Hp', 2, 300)
s = Scanner('Canon', 54000, 10)
x = Xerox('Xerox', 7000, 15)
p.income()
s.income()
x.income()


# In[ ]:


#Задание 7. Реализовать проект «Операции с комплексными числами». Создайте класс «Комплексное число». Реализуйте перегрузку методов 
#сложения и умножения комплексных чисел. Проверьте работу проекта. Для этого создаёте экземпляры класса (комплексные числа), 
#выполните сложение и умножение созданных экземпляров. Проверьте корректность полученного результата.
#Дополнительные материалы

class ComplexNumber:
    def __init__(self, a, b):
        self.a = a
        self.b = b

    def __add__(self, other):
        return f'Сумма равна: {self.a + other.a} + {self.b + other.b} * i'

    def __mul__(self, other):
        return f'Произведение равно: {self.a * other.a - (self.b * other.b)} + {self.b * other.a} * i'


c_1 = ComplexNumber(4, -8)
c_2 = ComplexNumber(6, 11)
print(c_1 + c_2)
print(c_1 * c_2)


# In[ ]:





# In[ ]:




